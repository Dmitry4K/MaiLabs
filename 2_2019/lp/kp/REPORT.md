# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Коростелев Д.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

В ходе выполнения данной лабораторной работы студент может познакомиться со всеми базовыми функциями и возможностями, встроенными средствами языка Prolog и системы программирования SWI-Prolog. 

Для выполнения данной работы также потребуется изучить, каким образом реализуются графы в Prolog, научится искать в них нужную информацию, научится работать со списками, научится применять полученные знание на практике


## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: ...
 3. Реализовать предикат проверки/поиска .... 
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Для получения полного родословного дерева потребовалось воспользоваться сервисом MyHeritage. Данный крайне удобен для построения и хранение родословных деревьев, доступны операции добавления, удаления и конкатенации элементов и поддеревьев. В ходе работы над данным заданием было получено информации около 80 потомков вплоть до 4ого поколения назад. Само дерево представлено в виде GEDCOM файла. 

## Конвертация родословного дерева

Для конвертации GEDCOM файла в предикаты Prolog использовался язык Python, так как весь GEDCOM файл имеет свою структуру, крайне просто было вычленить нужную и информацию и преобразовать ее в предикаты. 
Весь GEDCOM файл состоит из двух частей, первая содержит в себе информацию о вершинах графа, вторая о семьях в графе

## Предикат поиска родственника

Согласно варианту нужно реализовать предикат, вычисляющий свекровь от вершины 

```prolog
mother-in-law(X,Y):- female(X), female(Y), child(Child, Father) , child(Child, Y), child(Father, X).

?- mother_in_law(L,'@I500002@').
L = '@I500007@' ;
L = '@I500012@' ;
``` 


## Определение степени родства

Определение степени родства происходит за счет обхода графа поиском в глубину: 
```prolog
dfs([X|T], X, [X|T],[]).
dfs(P, F, L, A):-
    tprolong(P,P1, X),
    dfs(P1, F, L,A1),
    append(A1, [X], A).
```
Но помимо обычного обхода паралелльно составляется список родства между требуемыми родственниками, это происходит, когда в поиске в глубину требуется продлить путь:
```prolog
tprolong([X|T], [Y, X|T], father) :-
    father(X,Y), not(member(Y, [X|T])).
tprolong([X|T], [Y, X|T], mother) :-
    mother(X,Y), not(member(Y, [X|T])).
tprolong([X|T], [Y, X|T], son) :-
    son(X,Y), not(member(Y, [X|T])).
tprolong([X|T], [Y, X|T], son) :-
    son(X,Y), not(member(Y, [X|T])).
tprolong([X|T], [Y, X|T], daughter) :-
    daughter(X,Y), not(member(Y, [X|T])).
tprolong([X|T], [Y, X|T], brother) :-
    brother(X,Y), not(member(Y, [X|T])).
tprolong([X|T], [Y, X|T], sister) :-
    sister(X,Y), not(member(Y, [X|T])).
```
Вычисляются предикаты родства и если есть вхождение сохраняется соответствующий терм
Пример работы предиката: 
```prolog
?- relative(List,'@I500001@', '@I500015@').
List = [son, daughter, father].
?- relative([sister, son], '@I500001@', B).
B = '@I500007@'.
```
Стоит отметить, что такое неявное представление родственника через его id, используется мной специально, так как так проще хранить и обращаться к соответствующему родственнику, в ходе парсинга дерева все именна были сохранены и записаны в соответствующую базу данных предикатов.

```prolog
?- def_name_by_id(ID1, 'Дмитрий Коростелев'), def_name_by_id(ID2, 'Василий Коростелев'), relative(A, ID1, ID2).
ID1 = '@I500003@',
ID2 = '@I500001@',
A = [son].
```

## Выводы

По итогу выполнения курсовой работы я получил множество новых полезных знаний, я четко осознал разницу между императивной и логической парадигмой, понял их основные принципы и особенности, плюсы и минусы, научился пользоваться различными средствами пролога – обрабатывать списки, графы, вычислять предикаты и на их основе составлять целые базы. 
Усвоил для себя, что настоящий программист, должен уметь писать программы разными способами и разными методами, уметь применять ту или иную парадигму программирования для решения разных специфических задач.

