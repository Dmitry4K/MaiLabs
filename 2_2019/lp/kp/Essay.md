# Реферат
## по курсу "Логическое программирование"

### студент: Коростелев Д.В.

## ТЕМА
## Сравнение реализации алгоритмов поиска на логических и императивных языках.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение. 
Парадигма программирования – это совокупность принципов, правил и идей, в подходе к написанию различных программ. Впервые данный термин использовал в Робер Флойд в 1978 году в своей лекции процитировав Томаса Куна. 
На сегодняшний день существует огромное множество различных парадигм и методов подхода к реализации программ, но на данный момент используются следующие способы: императивное программирование, структурное программирование, объектно-ориентированное программирование функциональное программирование, логическое программирование. 
Порядок расположения приведенных выше парадигм не случаен – парадигмы расположены в порядке частоты и популярности применения для решения ряда прикладных задач. 
Как можно заметить на данный момент самым популярным способом программирования является императивный, в тоже время на последнем месте стоит логическое программирование. Но, взглянув на все вышеуказанные методы, можно понять, что та или иная парадигма обладает рядом плюсов и минусов, и чтобы конкретней разобраться в способах реализации алгоритмов поиска, следует сначала изучить основные принципы императивного и логического программирования.

## Императивное программирование, плюсы и минусы, подход к реализации программ.

Императивный подход к программированию является самой старой, но в тоже время популярной и основной парадигмой, которой пользовались и будут пользоваться программисты. 
Исторически сложилось, что самые первые процессоры выполняли своего рода определенные строго типизированные инструкции, то есть они действовали исключительно по ряду правил, которые программист задавал в коде программ на тривиальных низкоуровневых языках, позже на ассемблере, а затем на высокоуровневых тесно приближенных к процессорам. 
Собственно, как уже было отмечено ранее, императивная программа – это набор комбинированных инструкций, которые представляют сбой либо тривиальные операции, предусмотренные процессом, либо другие вложенные инструкции, причем все операции и инструкции выполняются последовательно.
Помимо этого, в императивном программировании крайне сильно распространено присваивание. У данной операции есть ряд преимуществ и недостатков – с одной стороны, при выполнении программы можно четко проследить каким образом различные объекты преобразуются, вычисляются, перепрививаются, с другой стороны, наличие такого оператора обязывает либо самого программиста, либо средства языка следить за приведениями типов, и если с базовыми типами, можно совершить такое привидение, то с более сложными комбинированными структурами, задаваемыми пользователем, такая определение приведения типа лежит на плечах программиста. В связи с этим возникает ряд специфических ошибок, когда переменной одного типа, не может быть присвоена переменная другого. Из-за этого одним, из основных минусов императивного программирования является сложность обучения императивным языкам и чересчур доскональное описание требуемых действий и способов вычисления, хранения и преобразования информации. 
Исходя из этого можно выделить основные черты императивного программирования
•	Программы – это набор последовательно заданных строгих инструкций

•	Используется операция присваивания

•	Используются составные выражения

•	Используются подпрограммы

•	Данные могут записываться либо в память, либо в переменную.

Исходя из всего выше указанного при подходе к написанию алгоритма нужно выделить четкую цепочку последовательных действий, которая преобразует один набор данных согласно другому, сами действия тоже следует разбивать на более мелкие операции, проследить цепочку преобразований над данными, позаботиться об их хранении, учесть все возможно критические ситуации.

## Логическое программирование, плюсы и минусы, подход к реализации программ

Логическое программирование как парадигма программирования появилась в результате потребности автоматизации решения ряда специальных задач, теорем. Сложность при императивном подходе состояла в том, что для доказательства одной такой задачи требовалось бы разработать огромный пласт функций, инструкций, задать изначальные условия задачи, которые были бы понятны и могли быть преобразованы вычислительной машиной, основанной на принципе машины Тьюринга. 
Первый логический язык программирования появился в 1969 году и имел название PLANNER, который был разработан Карлом Хьюитом, за основу языка был взят LISP, к которому был добавлен ряд новых возможностей. Отличительной чертой Planner стал режим возвратов, который позволял программе отказываться от ранее принятых решений, если становилось понятным, что дальнейшие действия не приведут к решению, так называемый механизм бэктрекинга, это позволяло программисту не заботится о необходимости реализации полного перебора. Благодаря такому нововведению, язык Карла Хьюита оказал сильное влияние в области искусственного интеллекта и дал серьезный толчок дальнейшим исследованиям.  
Позже появился язык Prolog, который в отличие от Planner, не требовал плана перебора вариантов, да и в целом за сложной технической реализацией языка стояла его простота и удивительная читаемость программ, написанных на Prolog. На данный момент Prolog является одним из самых популярных логических языков программирования.
Принцип работы на логических языках состоит в том, что программист задает какую-то изначальную базу свойств и данных и исходя из нее, по каким правилам и логике расширяет ее, посредством полного перебора всех возможных вариантов (механизм бэктрекинга и отсеивание ложных вариантов) . Особенностью логического программирования является отсутствие типов данных, явной последовательности действий, в отличие от того же императивного подхода. Все задачи, решаемые логическим программированием, можно перевести на язык математической логики. Несмотря на отсутствия типов в логическом программировании здесь имеется своеобразная операция унификации, которая в процессе работы программы сопоставляет между собой различные переменные или термы (если отображать память Prolog, то у каждой переменной будет свой индекс, по которому хранится объект).

Таким образом можно выделить несколько идей логической программирования

•	Задание исходной базы данных, набор предикатов или свойств различных предметов.

•	Задание ряда правил, условий решаемой задачи, которые могут либо расширять заданную базу данных, либо формировать новые правила и состояния (метод резолюций)

•	Процесс унификации переменных.

Не смотря, на все преимущества, описанные выше, логическое программирование обладает своими недостатками, а именно – применяется для решения специфических и узких задач (обработка текста, док-во утверждений и т.п.), а также его скорость работы, которая из-за механизма полного перебора всех возможных вариантов довольно низкая. Кроме того, в некоторых ситуациях кол-во памяти, требуемое логической программе сильно больше, чем программе, написанной на другой парадигме. 
При реализации программ на логическом языке, нужно задуматься, что хотим доказать, получить, написать начальный, стартовый набор предикатов, согласно условию задач, сформировать набор правил, продумать логику выполнения задачи, всегда нужно помнить, что в логическом программировании не предусмотрена операция присваивания, все действия и преобразования происходит за счет функций и предикатов.

## Алгоритмы поиска на языке С++.
Одними из важнейших процедур обработки структурированной информации является поиск. Поиск может осуществляться в различных структурах, контейнерах, текстах. 
Одной из таких структур являются графы разных видов. На данный момент существует множество различных способов, алгоритмов поиска в графах и их обхода. Такими поисками являются поиск в глубину, ширину, с итеративным заглублением и так далее. Для сравнения алгоритмов поиска будет рассмотрен алгоритм поиска в ширину, реализованный на языке с++, и языке Prolog.
Алгоритм поиска в глубину – это рекурсивный алгоритм обхода вершин, его суть состоит в том, чтобы продвигаться вглубь по графу, пока это возможно. Невозможность дальнейшего продвижения означает, что следующим шагом будет переход на последний, имеющий несколько вариантов движения.
На языке С++ данный алгоритм имеет следующую реализацию:
```c++
const int n=5;
int graph[n][n] =
{
{0, 1, 0, 0, 1},
{1, 0, 1, 1, 0},
{0, 1, 0, 0, 1},
{0, 1, 0, 0, 1},
{1, 0, 1, 1, 0}
};
vector <int> visited;
void DFS(int st)
{
	int r;
	visited[st]=true;
	for (r=0; r<=n; r++)
		if ((graph[st][r]!=0) && (!visited[r]))
			DFS(r);
}
```
Как видим данный алгоритм работает с матрицей смежностей графа, алгоритм поиска в глубину представленный в данном  варианте задается стартовая вершина и уже от этой вершины ищется смежная ей вершина, при том такая, что не была пройдена ранее, если такая находится, старая записывается в специальный массив, в котором содержатся уже ранее пройденные вершины, далее проход рекурсивно начинается от следующей вершины. 
Все действия в данном алгоритме происходят непосредственно над графом, заданным в специальном массиве, в процессе поиска происходит ряд обращений к тому или иному элементу графа. В работы цикла, счетчики постоянно обновляются, пере присваиваются.
Стоит отметить, что представленный здесь алгоритм в таком не является алгоритмом поиска графа, однако данный пример может быть расширен до алгоритма поиска, в него достаточно добавить нужное условие и параметр, по которому производится поиск. 
## Алгоритмы поиска на языке Prolog.
Теперь рассмотрим тот же поиск в ширину, но представленный на языке Prolog. Суть алгоритма не меняется – рекурсивно опускаемся вниз, пока это возможно, иначе ищем путь от предыдущей вершины к следующей, параллельно запоминая уже пройденные вершины.
Реализация данного алгоритма состоит из нескольких предикатов. Для начала стоит отметить, что графы в логическом программировании представляют из себя набор предикатов-ребер вершин, которые соединяются между собой.
```prolog
tprolong([X|T], [Y, X|T]):-
    next_step(X,Y),
    not(member(Y, [X|T])).
dfs([X|T], X, [X|T]).
dfs(P, F,L):-
    tprolong(P,P1),
    dfs(P1, F,L).
```
Предикат поиска в ширину будет включать в себя три аргумента – первый, стартовая точка, второй – итоговая, третья – пройденный путь до точки.
Далее реализуется основной алгоритм, который стоит начать с того, что задать предикат остановки поиска. Поиск будет начинать сворачивать когда, мы собственно дойдем до нужной точки. Предикат будет выглядеть примерно так – dfs([X|T], X, [X|T]). Здесь мы говорим, что когда начальная стартовая точка X совпадает с конечной, тоесть тоже является X, то в список с уже пройденным путем добавляется наша конечная, точка.

Далее реализуется предикат самого прохождения, который выполняется путем вхождения двух предикатов. Предикат prolong отвечает за продление пути, проверки возможности перехода от одной точки к другой. Кроме того, данный предикат проверяет заходили ли мы в точку, в которую можем попасть или нет. Таким образом prolong продляет путь в ранее не пройдённые точки, ставя в соответствие между собой две вершины графа.
Второй предикат – рекурсивный запуск поиска в ширину, по точке, полученной прошлым предикатом, если такая имеется, до точки назначения.
Весь данный алгоритм можно описать математическим языком: 
1)	от точки А до точки Б существует путь, если из точки можем перейти в вершину В, при этом ранее данная вершина не была посещена и от вершины В существует путь в А. 
2)	точка A, является путем до точки Б, если точка А есть точка Б.
tprolong([X|T], [Y, X|T]):-
    next_step(X,Y),
    not(member(Y, [X|T])).
dfs([X|T], X, [X|T]).
dfs(P, F,L):-
    tprolong(P,P1),
    dfs(P1, F,L).
Как можно заметить в отличие от реализации на С++ код программы теперь представляет из себя своего рода математическую модель, теорему, следуя которой можно пройтись по графу да заданной вершины.
## Заключение.
 Не сложно убедится, что одинаковые алгоритмы на разных языках, парадигмах программирования имеют разные реализации с точки зрения представления программы.
На императивных языках программы представляют из себя последовательно идущие операции с возможными ветвлениями и сильно выраженным пере присваиванием данных, и если на С++, в силу его специальных возможностей, использования указателей можно это в какой-то мере избежать, то если взять алгоритм поиска на языке Java, где главным у переменной является ее значение, без пере присваивания не обойтись. Из-за этого создается большая вероятность возникновения ошибок типов данных и увеличивается сложность кода.
На логических языках алгоритм поиска представляется в виде правил декретной математики, все проходы по вершинам осуществляются при помощи обработки вхождений предикатов (осуществляется полный перебор), в итоге мы получаем крайне удобный для прочтения код, в то же время работа такой программы по сравнению с императивными языками сильно уступает. 

## Список использованной литературы
1)	Д.В. Сошников “парадигма логического программирования»
2)	Р.В. Флойд «прадигмы логического программирования»
3)	Кормен Т., Лейзерсон Ч., Ривест Р. Глава 22. Элементарные алгоритмы для работы с графами
