# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Коростелев Д.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Одной из структур данных поддерживаемыми языком Prolog является список. Список в Prolog состоит из двух компонентов – головы и хвоста, где голова – первый элемент в списке, может являться как переменной, так и другим списком, хвост – оставшаяся часть списка, представляет из себя список (пустой или не пустой). Например: [1,2,3] – 1 – голова, [2,3] – хвост. Стоит рассмотреть и такой пример – [[1,2],2,3]. Здесь голова – [1,2], хвост – [2,3]. На этом примере можно понять, что в отличие от списков в императивных языках программирования в Prolog элементы списка могут быть абсолютно разными объектами. Кроме того, в императивных языках список – набор связанных между собой элементов, в Prolog – это бинарное дерево.

## Задание 1.1: Предикат обработки списка

`list_length(List, Length)` - предикат нахождения длины списка

Ставит в соответсвтие списку List его длину Length, реализован при помощи рекурсивного обхода списка

Примеры использования:
```prolog
?- list_length([1,2,3,4], Length).
Length=4.
```

Реализация:
```prolog
list_length([], 0):-!.
list_length([_Head|Tail], Length):-
    list_length(Tail, TailLength),
    Length is TailLength + 1.
```
Изначально любому пустому списку ставится в соответствие 0, далее за счет рекурсивного обхода у заданного списка мы спускаемся вниз, отсекая голову, а затем возвращаемся, инкрементируя с каждым шагом значение Length. По итогу получаем итоговую длину заданного списка. 

`list_member(Elem, List)` - предикат наличия элемента в списке
Примеры использования:
```prolog
?- list_member(3, [1,2,3,4]).
true.
?- list_member(5, [1,2,3,4]).
false.
```

Реализация:
```prolog
list_member(Elem, [Elem|_Tail]).
list_member(Elem, [_Head|Tail]):-
   list_member(Elem, Tail).
```
Поиск элемента состоит из двух предикатов – если первый элемент в списке совпадает с элементов который мы ищем, и если не нашли нужный элемент, то отделяем голову, и ищем этот элемент в хвосте.

`list_append(List1, List2, Result)` - предикат объединения двух списков
Примеры использования:
```prolog
?- list_append([1,2], [2,3], List).
List=[1,2,2,3].
```
Реализация:
```prolog
list_append([], List2, List2).
list_append([Head|Tail], List2, [Head|Tailresult]):-
   list_append(Tail, List2, Tailresult).
```
Конкатенация двух списков – если к пустому списку добавляем какой-то другой список, то получаем тот же список. Далее из двух не пустых списков по средством отделения головы от первого списка формируем хвост для ответа

`sublist(Sub, List)` - предикат вложенности списков
Примеры использования:
```prolog
?- sublist([1,2], [2,3]).
false.
?- sublist([1,2], [1,2,3]).
true.
```
Реализация:
```prolog
sub_start([], _List):-!.
sub_start([Head|TailSub], [Head|TailList]):-
   sub_start(TailSub, TailList).
sublist(Sub, List):-
   sub_start(Sub, List), !.
sublist(Sub, [_Head|Tail]):-
   sublist(Sub, Tail).
```
Поиск вхождения списка в другом списке основан на двух правил. Sub_start – смотрит вхождение списка в другом списке – проверяет голову у двух списков, если они совпадают, то двигаемся дальше до того момента, пока первый не обнулиться. Запускаем sub_start от любой позиции в списке и потом отделяем голову у первоначального элемента и запускаем sub_start от первого элемента хвоста.

`list_remove(Elem, List, Result)` - предикат удаления элементов
Примеры использования:
```prolog
?- list_remove(1, [1,2], List).
List=[2].
?- list_remove(3, [1,2], List).
false.
```
Реализация:
```prolog
list_remove(Elem, [Elem|Tail], Tail).
list_remove(Elem, [Head|Tail], [Head|TailResult]):-
    list_remove(Elem, Tail, TailResult).
```
Удаление – в основе предикат list_remove(Elem, [Elem|Tail], Tail) где элементу со списком, чья голова является элементом, ставится в соответствие хвост списка. Получается так, что одно вхождение такого предиката говорит о следующем – если первый элемент списка совпадает с элементом, который нужно удалить, то после удаления получится хвост списка. Далее рекурсивно проходим по списку, проверяем предикат.

`permute(List, Permutation)` - перестаовки списков
Примеры использования:
```prolog
?- permute([1,2,3], List).
List = [1, 2, 3] ;
List = [1, 3, 2] ;
List = [2, 1, 3] ;
List = [2, 3, 1] ;
List = [3, 1, 2] ;
List = [3, 2, 1] ;
false.
```

Реализация:
```prolog
permute([],[]).
permute(List, [Head|Tail]):-
   list_remove(Head, List, R),
   permute(R, Tail).
```
Перестановка списков – из двух входных списков удаляется первый элемент, оставшиеся элементы сравниваются на перестановочность и рекурсивно генерируются все возможные варианты.



## Задание 1.2: Предикат обработки числового списка

`list_next(Elem , List, NextElem)` - предикат получения следющего элемента после заданного

Примеры использования:
```prolog
?- list_next(1, [1,2,3], Elem).
Elem = 2 ;
false.
?- list_next(1, [1,2,1], Elem).
Elem = 2 ;
false.
?- list_next(1, [1,2,1,5], Elem).
Elem = 2 ;
Elem = 5 ;
false.
```

Реализация:
```prolog
list_next(Elem , List, NextElem):-
   list_append(_,[Elem, NextElem|_], List).
   
list_next_s(Elem, List, NextElem):-
   append(_, [Elem,NextElem|_], List).
```
Способ нахождения предиката двольно прост - проверяем все вхождения, когда из двух других списков, при чем у второго после заданного элемнета следует искомый можем получить в процессе конкатенации зданный список. Как для реализации через стандартные функции, так и через свои я использовал предикат соединения двух списков. 


## Задание 2: Реляционное представление данных

В ходе выполнения данного задания сформировалось некоторое представление о реляционных моделях баз данных. Элементом такой базы данных является структура, в которой содержится некоторый набор атомов, причем каждый атом на определённом месте обладает своей семантикой, в связи с этим возникает ряд трудностей при обработке таких баз данных. При запросе к элементам таких БД получаем множество удовлетворяющих элементов внутренней структуре, что в некоторых ситуациях сильно усложняет обработку. Так приходится следить за тем, чтобы итоговые предикаты обработки полностью охватывали заданное множество (например предикаты вычисляющие списки не имели повторений, либо, наоборот - были нужной длины и включали все необходимые вхождения. С другой стороны, благодаря реляционным базам данных, мы получаем довольно удобную таблицу, которая может с легкостью расширяться , быть понятной обычному пользователю и легко переносится из одной системы в другую.


Предикат №1 `middle_mark(Group, Mark)` (Получить таблицу групп и средний балл по каждой из групп)
Реализация:
```prolog
middle_mark(Group, Mark):-
    student(Group, Student),
    findall(Mark,sub_predict(Student, _,Mark,Group),  List),
    sum_list(List, Sum),
    length(List, Length),
    Mark is Sum/Length.
    
%-предикат который находит полную информацию о студенте, а также его оценки за все предметы
sub_predict(Student, Subject ,Mark , Group):-
    grade(Student, Subject ,Mark),
    student(Group, Student).
```

Пример использования:
```prolog
middle_mark(101, Mark).
Mark = 3.8154761904761907 ;
```

Данный предикат находит среднюю оценку в группе по следующим правилам, находится список с помощью предиката findall по предикату grade с всеми оценками учеников заданной группы по всем предметам, далее ищется его длина и общая сумма всех элементов в списке. В Mark записывается среднее арифметическое

Предикат №2 `list_of_not_passed_student(Subject, List)` (Для каждого предмета получить список студентов, не сдавших экзамен (grade=2))
Реализация:
```prolog
%-генерирует список List, по заданному предмету Subject
list_of_not_passed_student(Subject, List):-
	bagof(Student, not_passed_subject(Subject, Student), List).

%-предикат который ставит в соответствие предмет со студентом, если тот не сдал предмет
not_passed_subject(Subject, Student):-
    grade(Student, Subject, Mark),
    Mark < 3.
```

Пример использования:
```prolog
list_of_not_passed_student(Subject, List).
Subject = 'ENG',
List = ['Эфиркина'] ;
Subject = 'FP',
List = ['Криптовалютников'] ;
Subject = 'INF',
List = ['Эфиркина', 'Джаво', 'Безумников'] ;
Subject = 'LP',
List = ['Запорожцев', 'Эфиркина', 'Текстописов'] ;
Subject = 'MTH',
List = ['Запорожцев', 'Круглосчиталкин', 'Густобуквенникова', 'Криптовалютников', 'Блокчейнис', 'Азурин'] ;
Subject = 'PSY',
List = ['Биткоинов', 'Текстописова', 'Криптовалютников', 'Азурин', 'Вебсервисов'].
```

Довольно простой предикат – формируем список с помощью bagof по предикату not_passed_subject который в свою очередь формирует вхождения при том, если у студента есть оценка по предмету и она ниже 3.

Преидкат №3 `count_of_not_passed_student_in_group(Group, Count)` (Найти количество не сдавших студентов в каждой из групп)
Реализация:
```prolog
%-подсчет кол-ва студентов в группе не сдавших экзамен
count_of_not_passed_student_in_group(Group, Count):-
	setof(Student, not_passed(Student, Group), List),
	length(List, Count).
%-предикат поиск несдавшего экзамен студента
not_passed(Student, Group):-
	student(Group, Student),
	grade(Student, _ ,Mark),
	Mark < 3. 
```

Почти аналогичный предикат к тот, что описанный выше, однако здесь для того чтобы узнать кол-во студентов не сдавших экзамен находится список таких студентов и благодаря setof этот список содержит только уникальные элементы. Предикат not_passed считается по правилам, если студент принадлежит заданной группе, у него есть оценка по предмету и она меньше 3

Пример использования:
```prolog
count_of_not_passed_student_in_group(Group, Count).
Group = 101,
Count = 2 ;
Group = 102,
Count = 4 ;
Group = 103,
Count = 3 ;
Group = 104,
Count = 4.
```


## Выводы

Данная лабораторная работа в целом позволяет ознакомится с базовыми возможностями языка Prolog, учит работе со списками и стандартными база данными. В ходе выполнения с заданиями столкнулся с рядом проблем – сначала было сложно понять по каким правилам работают декларативные, но позже, с пониманием его основных принципов становятся очевидны плюсы данных языков – отсутствие типизации значений, удобные в обращении списки и крайне удобная обработка баз данных, заданными специальными предикатами, в целом могу сказать, что Prolog может быть применим для решения ряда специфичных задач.
